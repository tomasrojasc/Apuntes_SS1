<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Resumen_C1</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>

<style type="text/css">
div.prism-show-language {
	position: relative;
}

div.prism-show-language > div.prism-show-language-label {
	color: black;
	background-color: #CFCFCF;
	display: inline-block;
	position: absolute;
	bottom: auto;
	left: auto;
	top: 0;
	right: 0;
	width: auto;
	height: auto;
	font-size: 0.9em;
	border-radius: 0 0 0 5px;
	padding: 0 0.5em;
	text-shadow: none;
	z-index: 1;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
	box-shadow: none;
	-webkit-transform: none;
	-moz-transform: none;
	-ms-transform: none;
	-o-transform: none;
	transform: none;
}
</style>


</head>

<body>

<h1 id="toc_0">Apunte Señales y Sistemas I</h1>

<p>Por: Tomás Rojas</p>

<h1 id="toc_1">Señales, sistemas y procesamiento de señales</h1>

<blockquote>
<p>Definición: Una <strong>señal</strong> es cualquier cantidad física que varia en el tiempo, en el espacio o cualquier otra variable.</p>
</blockquote>

<p>Algunos ejemplos de señales pueden ser polinomios que dependan del tiempo o del espacio o cualquier cosa.</p>

<p>Hay señales que pueden ser especificadas de manera funcional (con funciones), pero este no es siempre el caso.</p>

<p>Si tomamos un audio de una charla, no es una señal definida funcionalmente, pero podemos descomponerla en suma de senos y cosenos:</p>

<p>\[\sum_{i=1}^NA_i(t)\sin[2\pi F_i(t)t+\theta_i(t)]\]</p>

<p>Donde \(\{A_i\},\{F_i\},\{\theta_i\}\) son conjuntos de Amplitudes, Frecuencias y Fases respectivamente, que bien podrían variar en el tiempo.</p>

<p>Otro ejemplo de señal puede ser un electrocardiograma. Esta señal le entrega información a un médico sobre la condición en que se encuentra el corazón de su paciente. De manera similar, un electroencefalograma da información de la actividad cerebral.</p>

<p>Todos los sistemas mencionados son ejemplos de sistemas que dependen se solo una variable independiente, el tiempo... Un ejemplo de un sistema con más variables independientes puede ser una imagen.</p>

<p>Un sistema también puede ser definido como un aparato físico que ejecuta cierta operación sobre una señal. Por ejemplo un filtro puede ser tratado como un sistema.</p>

<p>Cuando pasamos una señal por un sistema, decimos que la procesamos. En general, un sistema está caracterizado por el tipo de operación que aplica a una señal.</p>

<h2 id="toc_2">Clasificación de señales</h2>

<blockquote>
<p>lo voy a dejar en blanco ya que no es tan importante para el C1, más adelante volveré a llenar esto</p>
</blockquote>

<h2 id="toc_3">Señales en tiempo continuo versus señales en tiempo discreto</h2>

<h3 id="toc_4">Señales sinusoidales continuas</h3>

<p>Un oscilador armónico simple puede ser descrito matemáticamente como:</p>

<p>\[x_a(t)=A\cos(\Omega t + \theta); \quad -\infty&lt;t&lt;\infty\]</p>

<p>El subíndice \(a\) hace referencia a que esta señal es analógica.</p>

<p>La frecuencia \(\Omega\) es frecuencia angular, en radianes, es común usar \(F\) que es en Hertz, donde \(\Omega=2\pi F\)</p>

<p>La señal sinusoidal analógica está caracterizada por las siguientes propiedades:</p>

<ul>
<li><em>Para cualquier valor fijo de frecuencia \(F\), $x</em>a(t)\( es periódica._ Esto es
\)\(x_a(t+T_p)=x_a(t), \quad T=1/F\)$</li>
<li>_Señales análogas sinusoidales con distintas frecuencias, <strong>son</strong> distintas_.</li>
<li><em>Incrementar la frecuencia implica incrementar las oscilaciones de una señal en un tiempo dado.</em></li>
</ul>

<p>Podemos notar que para \(F\to 0\) entonces \(F \to \infty\)</p>

<h3 id="toc_5">Señales sinusoidales discretas</h3>

<p>Podemos expresar matemáticamente una señal sinusoidal discreta de la siguiente manera:</p>

<p>\[x(n)=A\cos(\omega n + \theta); \quad -\infty&lt;n&lt;\infty\]</p>

<p>Acá también tenemos otra frecuencia:</p>

<p>\[\omega \equiv 2\pi f\]</p>

<p>Podemos ver las siguientes propiedades de este tipo de señales:</p>

<ul>
<li>_Una señal sinusoidal discreta es periódica <strong>solo</strong> si su frecuencia \(f\) es un nro racional_.</li>
</ul>

<p>Por definición tenemos que una señal discreta es periódica con periodo \(N \quad (N&gt;0)\)  ssi:<br>
\[x(n+N)=x(n)\quad \forall n\]</p>

<p>El valor más pequeño de \(N\) para el que esto se cumple, se llama <em>periodo fundamental</em>.</p>

<blockquote>
<p><strong>Demostración:</strong><br>
\[\cos[2\pi f_0(N+n)+\theta]=\cos(2\pi f_0n+\theta)\]<br>
\[2\pi f_0 N =2k\pi\]<br>
\[f_0=\frac{k}{N}\]</p>
</blockquote>

<p>Por lo que es periódica sólo si su frecuencia \(f_0\) es una fracción entre dos enteros i.e. es racional.</p>

<ul>
<li>_Sinusoides discretas cuyas frecuencias están separadas por un múltiplo entero de \(2\pi\) son <strong>indénticas</strong>._</li>
</ul>

<p>Para probar esto, consideremos \(\cos(\omega_0n+\theta)\)<br>
\[\cos[(\omega_0 +2\pi)n+\theta]=\cos (\omega_0 n + 2\pi +\theta)= \cos(\omega_0n+\theta)\]</p>

<p>Como consecuencia de esto, <strong>todas</strong> las secuencias sinusoidales que cumplan:</p>

<p>\[x_k(n)=A\cos(\omega_k n+\theta); \quad k=0,1,2,3,...\]</p>

<p>Donde:</p>

<p>\[\omega k =\omega_0+2k\pi, \quad -\pi \leq \omega_0 \leq \pi\]</p>

<p>Son <strong>indistinguibles</strong>, por lo mismo, nos interesan frecuencias en los rangos \(-\pi \leq \omega \leq\pi\) o bien \(-1/2\leq f\leq1/2\)</p>

<ul>
<li>_La oscilación más rápida que puede tener una señal sinusoidal discreta es cuando \(\omega=\pm\pi\) o bien \(f=\pm 1/2\)</li>
</ul>

<p>En la siguiente imagen podemos ver la señal \(x(n)=\cos\omega_0n\) con distintos valores para \(\omega_0\)</p>

<p><img src="./img/img1.png" alt=""><br>
<strong>Figura 1:</strong> Imagen sacada de <em>Digital Signal Processing</em></p>

<h2 id="toc_6">Analógico a digital y digital a analógico</h2>

<p>Muchas señales de interés son analógicas. Para procesar una señal analógica de manera digital, primero hay que digitalizarla.</p>

<blockquote>
<p>Esto tampoco es pertinente para el C1, por lo que lo dejaré para después</p>
</blockquote>

<h3 id="toc_7">Teorema del muestreo</h3>

<p>Si tenemos una señal analógica ¿Como encontramos la frecuencia de muestreo \(F_s\)? Para responder esta pregunta es necesario conocer ciertas características de la señal de interés. En particular, tenemos que tener ciertas nociones del <em>contenido frecuencial</em> de la señal. Por lo general podemos conocer esa información en forma de cotas superiores.</p>

<p>Supongamos que cualquier señal analógica puede ser representada como un suma de senos (Fourier se encarga de eso).</p>

<p>\[x_a(t)=\sum_{i=1}^NA_i\cos(2\pi F_it+\theta_i)\]</p>

<p>Donde \(N\) es el número de frecuencias presentes.</p>

<p>El teorema nos dice que (se viene golazo, pero en virtud del tiempo lo voy a plantear no más, en todo caso es fácil de ver que tiene que ver con el aliasing de las señales al tomar mal la frecuencia de muestreo) \(F_s&gt;2F_{\text{max}}\)</p>

<p>Donde \(F_{\text{max}}\) es la frecuencia más alta presente en la señal.</p>

<p>Usando esto, cualquier componente de frecuencia \(|F_i|&lt;F_{\text{max}}\), en analógica, pasa a ser una señal sinusoidal discreta con una frecuencia:</p>

<p>\[-\frac{1}{2}\leq f_i=\frac{F_i}{F_s}\leq \frac{1}{2}\]</p>

<p>o de manera equivalente:</p>

<p>\[-\pi\leq \omega_i=2\pi f_i\leq \pi\]<br>
Como \(|f|=1/2\) o \(|\omega|=\pi\) son las frecuencias más altas en tiempo discreto, si escogemos el muestreo como se mostró, se evita el problema del aliasing.</p>

<p>Así la condición \(F_s&gt;2F_{\text{max}}\) garantiza que el mapeo de frecuencias continuas pase con relación 1 a 1 al dominio discreto.</p>

<p><strong>Teorema del muestreo:</strong><br>
Si la frecuencia más alta contenida en una señal analógica \(x_a(t)\) es \(F_{\text{max}}=B\) y la señal se muestrea de tal manera que \(F_s&gt;2B\), entonces \(x_a(t)\) puede ser recuperada con la función interpolación</p>

<p>\[g(t)=\frac{\sin2\pi B t}{2\pi B t}\]</p>

<p>Así \(x_a(t)\) puede ser expresada como:</p>

<p>\[x_a(t)=\sum_{n=-\infty}^\infty x_a\left(\frac{n}{2B}\right)\frac{\sin[ 2 \pi B(t-n/2B)]}{2 \pi B(t-n/2B)}\]</p>

<blockquote>
<p>TODO: Falta poner un par de imágenes</p>
</blockquote>

<h1 id="toc_8">Señales y sistemas en tiempo discreto</h1>

<p>En esta sección se ven mucho los sistemas LTI, tema central del curso.</p>

<h2 id="toc_9">Señales en tiempo discreto</h2>

<p>Una señal en tiempo discreto \(x(n)\) es una función de una variable independiente que es un entero. Como muestra la <em>figura 2</em>, la señal <strong>no está definida</strong> para valores de \(n\) que no sean enteros (ni siquiera es 0).</p>

<p><img src="./img/img2.png" alt=""><br>
<strong>Figura 2</strong></p>

<h2 id="toc_10">Señales elementales en tiempo discreto</h2>

<h4 id="toc_11">1.- Muestra unitaria</h4>

<p>Es una señal que es 1 en 0 pero 0 en todo lo demás</p>

<p>\[\delta(n)=<br>
\begin{cases}<br>
  1, &amp;\quad \text{para } n=0\\<br>
  0, &amp;\quad \text{para } n\neq0<br>
\end{cases}<br>
\]</p>

<h4 id="toc_12">2.- Señal escalón unitario</h4>

<p>\[<br>
u(n)=<br>
\begin{cases}<br>
  1, &amp;\quad \text{para } n\geq 0\\<br>
  0, &amp;\quad \text{para } n&lt;0<br>
\end{cases}<br>
\]</p>

<h4 id="toc_13">3.- Señal rampa unitaria</h4>

<p>\[<br>
u_r(n)=<br>
\begin{cases}<br>
  n, &amp;\quad \text{para } n\geq 0\\<br>
  0, &amp;\quad \text{para } n&lt;0<br>
\end{cases}<br>
\]</p>

<h4 id="toc_14">4.- Señal exponencial</h4>

<p>\[<br>
x(n)=a^n \quad \forall n<br>
\]</p>

<p>A puede ser real o complejo, si usamos propiedades los complejos, tenemos:</p>

<p>\[<br>
x(n)=r^ne^{jn\theta}<br>
\]</p>

<p>Que tiene parte real e imaginaria dadas por la identidad de Euler.</p>

<h2 id="toc_15">Clasificación de las señales discretas en el tiempo (energía y potencia)</h2>

<h3 id="toc_16">Energía de una señal</h3>

<p>La energía \(E\) de una señal viene dada por:</p>

<p>\[<br>
E\equiv \sum_{n=-\infty}^\infty|x(n)|^2<br>
\]</p>

<p>Usamos el cuadrado de la función ya que esta sirve para señales tanto reales como complejas. La energía de una señal puede o no ser finita. Cuando la energía de una señal es finita, se dice que es una <em>señal de energía</em></p>

<p>Definimos además la energía de una señal en un intervalo finito \(-N\leq n \leq N\)</p>

<p>\[<br>
E_N\equiv\sum_{n=-N}^N|x(n)|^2<br>
\]</p>

<p>así podemos redefinir la energía como</p>

<p>\[<br>
E\equiv \lim_{N \to \infty} E_N<br>
\]</p>

<h3 id="toc_17">Potencia media de una señal</h3>

<p>Muchas señales con energía infinita, tienen potencia media finita. La potencia media de una señal discreta se define como:</p>

<p>\[<br>
P=\lim_{N \to \infty} \frac{1}{2N+1}\sum_{n=-N}^N|x(n)|^2<br>
\]</p>

<p>También podemos definir la potencia media como:</p>

<p>\[<br>
P\equiv \lim_{N \to \infty}\frac{1}{2N+1}E_N<br>
\]</p>

<h3 id="toc_18">Periodicidad de una señal</h3>

<p>Una señal es periódica con periodo \(N \quad (N&gt;0)\) ssi:</p>

<p>\[<br>
x(n+N)=x(n) \qquad \forall n<br>
\]</p>

<p>El valor más pequeño de \(N\) para el cual lo anterior es válido, se llama el <em>periodo fundamental de la señal</em> Si no hay valor que satisfaga esta relación, entonces se dice que la señal es no-periódica o a-periódica.</p>

<p>La energía de una señal periódica \(x(n)\) en un periodo ---Por ejemplo \(0\leq n\leq N-1\)--- es finita si solo toma valores finitos en el periodo. Por otro lado la potencia media de una señal periódica es finita y es igual a la potencia media de un único periodo. Así si \(x(n)\) es una señal periódica con periodo fundamental \(N\) y toma valores finitos, tenemos que su potencia está dada por:</p>

<p>\[<br>
P=\frac{1}{N}\sum_{n=0}^{N-1}|x(n)|^2<br>
\]<br>
Así, las señales periódicas son señales de potencia.</p>

<h3 id="toc_19">Señales pares e impares</h3>

<p>Una señal real \(x(n)\) es simétrica o par si:</p>

<p>\[<br>
x(-n)=x(n)<br>
\]<br>
Por otro lado es antisimétrica o impar si:</p>

<p>\[<br>
x(-n)=-x(n)<br>
\]</p>

<p>Notemos que si \(x(n)\) es impar, entonces \(x(0)=0\)</p>

<p>Cualquier señal puede ser construida como una suma de una señal par y una impar.</p>

<p>La función par viene dada por:</p>

<p>\[<br>
x_e(n)=\frac{1}{2}[x(n)+x(-n)]<br>
\]</p>

<p>la impar por:</p>

<p>\[<br>
x_o(n)=\frac{1}{2}[x(n)-x(-n)]<br>
\]</p>

<p>Así:</p>

<p>\[<br>
x(n)=x_e(n)+x_o(n)<br>
\]</p>

<h2 id="toc_20">Manipulaciones simples de Señales a tiempo discreto</h2>

<p>Acá vamos a ver transformaciones simples de señales</p>

<h4 id="toc_21">Transformación de la variable independiente (tiempo)</h4>

<p>Una señal \(x(n)\) puede ser trasladada en el tiempo cambiando el argumento \(n\) por \(n-k\), donde \(k\) es un entero. Si es positivo, se traslada hacia la derecha (retardo) si es negativo hacia la izquierda (adelanto).</p>

<p>Otra transformación útil es la de reflexión temporal con respecto al origen, para esto basta con reemplazar el argumento \(n\) por \(-n\)</p>

<p><strong>Es importante notar que estas operaciones no son conmutativas entre sí.</strong></p>

<h3 id="toc_22">Sistemas en tiempo discreto</h3>

<p>Un sistema discreto es uno que recibe una señal discreta y aplica una operación de tal manera que la salida es también una señal discreta, llamada salida o respuesta del sistema.</p>

<p><img src="./img/img3.png" alt=""><br>
<strong>Figura 3</strong>: Representación de un sistema discreto</p>

<p>Cuando pasamos una señal \(x(n)\) por un sistema, decimos que aplicamos una transformación sobre la entrada para producir la salida \(y(n)\). Esta relación se expresa matemáticamente así:</p>

<p>\[<br>
y(n)\equiv \mathcal{T}[x(n)]<br>
\]</p>

<p>donde \(\mathcal{T}\) representa la transformación</p>

<p>Hay varias maneras de describir las características de un sistema de operaciones aplicadas a \(x(n)\) para producir \(y(n)\) Partamos con la descripción entrada-salida.</p>

<h2 id="toc_23">Descripción entrada-salida de un sistema</h2>

<p>En este caso el sistema se tomó como <em>caja negra</em></p>

<p>\[<br>
x(n) \xrightarrow[\qquad]{\mathcal{T}}y(n)<br>
\]</p>

<h3 id="toc_24">Clasificación de sistemas a tiempo discreto</h3>

<p>Tanto en el diseño como en el análisis de sistemas, nos interesa ver sus propiedades. Para poder hablar de propiedades de un sistema, estas tienen que satisfacerse para cualquier entrada que le pongamos, de otra manera no podemos hablar de que el sistema posea efectivamente la propiedad.</p>

<h4 id="toc_25">Sistemas estáticos versus sistemas dinámicos</h4>

<p>Un sistema se dice <em>estático</em> o <em>sin memoria</em> si la salida del sistema depende a lo más, del input que se está procesando en ese momento dado, esto es, que no está ni ahí con lo que pase antes o después, por eso sin memoria, como mi abuelita. En cualquier otro caso, se dice que el sistema es <em>dinámico</em> o que <em>tiene memoria</em>.<br>
Si la salida de un sistema en un tiempo \(n\) está totalmente determinada por las muestras de entrada den el intervalo desde \(n-N\) a \(n\) (\(N\geq0\)) Se dice que el sistema tiene duración de memoria \(N\), si \(N=0\) el sistema es estático. Si \(N\) es finito, el sistema tiene memoria finita, si \(N\) es infinito ---diverge---<br>
, el sistema tiene memoria infinita.</p>

<p>Los sistemas estáticos o sin memoria son descritos en general de la siguiente manera:</p>

<p>\[<br>
y(n)=\mathcal{T}[x(n),n]<br>
\]</p>

<h4 id="toc_26">Sistemas invariantes en el tiempo versus sistemas variantes en el tiempo</h4>

<p>Podemos subdividir los sistemas en sistemas variantes e invariantes en el tiempo. Un sistema se dice invariante en el tiempo si su característica entrada-salida no cambia en el tiempo.</p>

<blockquote>
<p>Definición: Un sistema relajado \(\mathcal{T}\) es <em>invariante en el tiempo</em> ssi:<br>
\[<br>
x(n)\xrightarrow[\quad]{\mathcal{T}}y(n) \implies x(n-k)\xrightarrow[\quad]{\mathcal{T}}y(n-k); \quad \forall \quad x(n),k<br>
\]</p>
</blockquote>

<p>Esta es la prueba que hay que aplicar para saber si un sistema es invariante en el tiempo. Primero excitamos un sistema con una entrada arbitraria y después usamos el operador de desplazamiento temporal.</p>

<p>\[<br>
y(n,k)=\mathcal{T}[x(n-k)]<br>
\]<br>
Si \(y(n,k)=y(n-k)\) para cualquier valor de \(k\), entonces el sistema <strong>es invariante en el tiempo</strong>.</p>

<h4 id="toc_27">Sistemas lineales versus sistemas no-lineales</h4>

<p>Un sistema lineal es aquel que satisface el <em>principio de superposición</em></p>

<blockquote>
<p>Definición: Un sistema es lineal ssi:<br>
\[<br>
\mathcal{T}[a_1x_1(n)+a_2x_2(n)]=a_1\mathcal{T}[x_1(n)]+a_2\mathcal{T}[x_2(n)]<br>
\]<br>
Para cualquiera entradas y constantes \(x_i(n), a_i\) respectivamente.</p>
</blockquote>

<h4 id="toc_28">Sistemas causales versus sistemas no-causales</h4>

<blockquote>
<p>Definición: Un sistema se dice <em>causal</em> si la salida del sistema para cualquier tiempo \(n\) depende solo de entradas presentes y/o pasadas, pero no de futuras. Matemáticamente:<br>
\[<br>
y(n)=F[x(n),x(n-1),x(n-2),...]<br>
\]<br>
donde \(F[\cdot]\) es una función arbitraria.</p>
</blockquote>

<p>Si un sistema no cumple con esta condición, se dice que es <em>no-causal</em></p>

<h4 id="toc_29">Sistema estable versus sistema inestable</h4>

<p>Kerimoh sistemas estables porque en la práctica son más útiles</p>

<blockquote>
<p>Definición: Un sistema se dice bounded input–bounded output (BIBO) estable ssi toda entrada acotada produce una salida acotada. Matemáticamente:<br>
\[<br>
|x(n)|\leq M_x&lt;\infty, \qquad |y(n)|\leq M_y&lt;\infty, \qquad \forall \quad n<br>
\]</p>
</blockquote>

<h3 id="toc_30">Interconexión de sistemas en tiempo discreto</h3>

<p>Los sistemas discretos en el tiempo pueden ser interconectados para crear sistemas más complejos, grandotes y fortotototes. Hay dos maneras básicas de conectarlos: en cascada (serie) o en paralelo.</p>

<p><img src="./img/img4.png" alt=""><br>
<strong>Figura 4:</strong> Ilustración de dos sistemas conectados en serie y en paralelo.</p>

<p>En el caso cascada tenemos<br>
\[<br>
y_1(n)=\mathcal{T}_1[x(n)]<br>
\]<br>
y la salida del segundo sistema es:</p>

<p>\[<br>
\begin{aligned}<br>
  y(n)&amp;=\mathcal{T}_2[y_1(n)]\\<br>
  &amp;=\mathcal{T}_2[\mathcal{T}_1[x(n)]]<br>
\end{aligned}<br>
\]</p>

<p>Notamos que los sistemas \(\mathcal{T}_1\) y \(\mathcal{T}_1\) pueden ser combinados de la siguiente manera:</p>

<p>\[<br>
\mathcal{T}_c \equiv \mathcal{T}_2\mathcal{T}_1<br>
\]</p>

<p>En general, el orden en que aplicamos los operadores es importante y</p>

<p>\[<br>
\mathcal{T}_1\mathcal{T}_2\neq \mathcal{T}_2\mathcal{T}_1<br>
\]<br>
pero si nuestros sistemas son lineales e invariantes en el tiempo, entonces \(\mathcal{T}_c\) es invariante y ahí sí \(\mathcal{T}_1\mathcal{T}_2 = \mathcal{T}_2\mathcal{T}_1\)</p>

<p>Para conexiones paralelas tenemos la misma idea:</p>

<p>\[<br>
\begin{aligned}<br>
  y_3(n)&amp;=y_1(n)+y_2(n)\\<br>
  &amp;=\mathcal{T}_1[x(n)]+\mathcal{T}_2[x(n)]\\<br>
  &amp;=(\mathcal{T}_1+\mathcal{T}_2)[x(n)]\\<br>
  &amp;=\mathcal{T}_p[x(n)]<br>
\end{aligned}<br>
\]</p>

<p>Donde \(\mathcal{T}_p=\mathcal{T}_1+\mathcal{T}_2\)</p>

<h2 id="toc_31">Análisis de señales a tiempo discreto en sistemas LTI</h2>

<p>La idea de esta sección es mostrar que los sistemas LTI están caracterizados por su respuesta a una muestra unitaria. De igual manera, vamos a mostrar que cualquier señal discreta se puede descomponer como una suma ponderada de muchas unidades. La forma general que relaciona la respuesta de impulso unitario (muestra unitaria) y la salida de un sistema a una entrada arbitraria, la suma de convolución, también será mostrada en esta sección. Así vamos a poder saber la salida de cualquier sistema con solo conocer la convolución y cómo se relaciona con el impulso unitario.</p>

<h3 id="toc_32">Técnicas para el análisis de sistemas lineales</h3>

<p>Hay dos métodos básicos para analizar el comportamiento o respuesta de un sistema lineal a una determinada entrada. Un método está basado en la solución directa de la relación entrada-salida del sistema, que en general, tiene la forma:</p>

<p>\[<br>
y(n)=F[y(n-1),y(n-2),...,y(n-N);x(n),x(n-1),...,x(n-M)]<br>
\]</p>

<p>donde \(F[\cdot]\) es una función de las cantidades entre los paréntesis. En particular, para un sistema LTI, veremos que la relación entrada-salida está dada por:</p>

<p>\[<br>
y(n)=-\sum_{k=1}^Na_ky(n-k)+\sum_{k=0}^Mb_kx(n-k)<br>
\]</p>

<p>donde \(\{a_k\}\) y \(\{b_k\}\) son parámetros constantes que especifican el sistema y son independientes de \(x(n)\) e \(y(n)\). La relación de entrada-salida se llama ecuación de diferencias y representa una manera de caracterizar el comportamiento de un sistema a tiempo discreto LTI.</p>

<h4 id="toc_33">Segundo método:</h4>

<p>Supongamos que la señal de entrada \(x(n)\) se descompuso en una suma ponderada de señales elementales \(\{x_k(n)\}\) de la siguiente manera:</p>

<p>\[<br>
x(n)=\sum_k c_k x_k(n)<br>
\]</p>

<p>donde \(\{c_k\}\) son un conjunto de amplitudes en la descomposición de la señal \(x(n)\). Ahora supongamos que la respuesta de un componente de señal \(x_k(n)\) es \(y_k(n)\). Así:</p>

<p>\[<br>
y_k(n)\equiv \mathcal{T}[x_k(n)]<br>
\]</p>

<p>Asumiendo que el sistema está relajado y la respuesta a \(c_kx_k(n)\) es \(c_ky_k(n)\), tenemos:</p>

<p>\[<br>
\begin{aligned}<br>
y(n)&amp;=\mathcal{T}[x(n)]=\mathcal{T}\left[\sum_kc_kx_k(n)\right]\\<br>
&amp;=\sum_kc_k\mathcal{T}[x_k(n)]\\<br>
&amp;=\sum_kc_ky_k(n)<br>
\end{aligned}<br>
\]</p>

<p>La base a escoger como nuestras <em>señales fundamentales</em> depende mucho de la naturaleza de las señales de entrada que estemos considerando. Por ejemplo si la entrada es periódica, una buena base serían exponenciales complejas:</p>

<p>\[<br>
x_k(n)=e^{j\omega_k n}, \qquad k=0,1,2,...,N-1<br>
\]<br>
donde las frecuencias \(\{\omega_k\}\) están relacionadas de manera armónica, esto es:</p>

<p>\[<br>
\omega_k\left(\frac{2\pi}{N}\right)k, \qquad k=0,1,2,...,N-1<br>
\]</p>

<p>La frecuencia \(2\pi/N\) es la <em>frecuencia funcdamental</em> y todos los componentes de más alta frecuencia de la base son multiplos enteros de esta.</p>

<h3 id="toc_34">Descomponiendo una señal en tiempo discreto a impulsos.</h3>

<p>Supongamos que tenemos una señal arbitraria $x(n) que queremos descomponer en una suma de impulsos unitarios. La descomposición matemáticamente se ve como sigue:</p>

<p>\[<br>
x_k(n)=\delta(n-k)<br>
\]</p>

<p>donde \(k\) representa el atraso de cada impulso individualmente.</p>

<p>Ahora supongamos que multiplicamos \(x(n)\) con \(\delta(n-k)\). Como el impulso es 0 en todos lados menos en \(n=k\) donde vale 1, el resultado es otro impulso solo que puede no valer 1, sino que vale \(x(k)\):</p>

<p>\[<br>
x(n)\delta(n-k)=x(k)\delta(n-k)<br>
\]<br>
si ahora repetimos lo mismo pero con \(m\) y con \(m\neq k\) podemos repetir lo mismo. Gráficamente, tenemos:</p>

<p><img src="img/img5.png" alt=""><br>
<strong>Figura 5:</strong> Representación gráfica de la descomposición de una señal en impulsos.</p>

<p>Así:</p>

<p>\[<br>
x(n)=\sum_{k=-\infty}^\infty x(k)\delta(n-k)<br>
\]</p>

<h3 id="toc_35">Respuesta de sistemas LTI a entradas arbitrarias: La suma de convolución</h3>

<p>Denotemos la respuesta a un componente de impulso como \(y(n,k)\), pero como es la respuesta al impulso en \(n=k\), de damos una letra especial \(h(n,k)\)</p>

<p>\[<br>
y(n,k)\equiv h(n,k) = \mathcal{T}[\delta(n-k)]<br>
\]</p>

<p>Pero podemos usar esto para una entrada arbitraria de la manera que vimos antes.</p>

<p>\[<br>
x(n)=\sum_{k=-\infty}^\infty x(n)\delta(n-k)<br>
\]</p>

<p>así tenemos :</p>

<p>\[<br>
\begin{aligned}<br>
y(n) &amp;= \mathcal{T}[x(n)]=\mathcal{T}\left[\sum_{k=-\infty}^\infty x(k)\delta(n-k)\right]\\<br>
&amp;=\sum_{k=-\infty}^\infty x(k)\mathcal{T}[\delta(n-k)]\\<br>
&amp;=\sum_{k=-\infty}^\infty x(k)h(n,k)<br>
\end{aligned}<br>
\]</p>

<p>Notemos que para lo anterior, no hubo que aplicar invarianza en el tiempo, de hecho si asumimos que nuestra señal es LTI, la cosa se pone más izipizi:</p>

<p>\[<br>
h(n)\equiv \mathcal{T}[\delta(n)]<br>
\]</p>

<p>aplicando invarianza en el tiempo:</p>

<p>\[<br>
h(n-k)= \mathcal{T}[\delta(n-k)]<br>
\]</p>

<p>Así:</p>

<p>\[<br>
y(n) = \sum_{k=-\infty}^\infty x(k)h(n-k)<br>
\]</p>

<p>Así, vemos que un sistema LTI está caracterizado por una sola función \(h(n)\) que es la <em>respuesta al impulso</em>. La relación de la ecuación anterior es la llamada <strong>suma de convolución</strong></p>

<p><strong>Receta:</strong> Para calcular la salida de convolución hacemos lo que sigue.</p>

<p>Supongamos que queremos calcular la salida de un sistema para un determinado tiempo \(n=n_0\). La respuesta, como vimos, está dada por:</p>

<p>\[<br>
y(n_0)=\sum_{k=-\infty}^\infty x(k)h(n_0-k)<br>
\]</p>

<p>Los pasos son:</p>

<ul>
<li><strong><em>Reflexión:</em></strong> Se refleja \(h(k)\) respecto a \(k=0\) para obtener \(h(-k)\)</li>
<li><strong><em>Desplazamiento:</em></strong> Se desplaza \(h(-k)\) una cantidad \(n_0\) hacia la derecha si \(n_0\) es positivo para obtener $h(n_0-k)</li>
<li><strong><em>Multiplicación:</em></strong> Se multiplica \(x(k)\) por \(h(n_0-k)\) para obtener la secuencia producto \(v_{n_0}\equiv x(k)h(n_0-k)\)</li>
<li><strong><em>Suma:</em></strong> Se suman todos los valores de la secuencia producto \(v_{n_0}(k)\) para obtener el valor de la salida en \(n=n_0\)</li>
</ul>

<p>La idea es usar esto para no solo un \(n_0\), sino que todos los infinitos \(n_0\)</p>

<h3 id="toc_36">Propiedades de la convolución y la interconexión de sistemas LTI</h3>

<p>Primero que nada, introducimos el asterísco como la convolución</p>

<p>\[<br>
y(n)=x(n)*h(n)\equiv \sum_{k=-\infty}^\infty x(k)h(n-k)<br>
\]</p>

<p>Lo interesante de esto es que podemos ver que el que esto conmute, es interpreteble como si tenemos un sistema que aplica \(h(n)\) y recibe \(x(n)\) es lo mismo que un sistema \(x(n)\) que recibe \(h(n)\)</p>

<p><img src="./img/img6.png" alt=""><br>
<strong>Figura 6</strong></p>

<h4 id="toc_37">Propiedades de identidad y desplazamiento</h4>

<p>El impulso unitario es el elemento identidad de la operación convolución, esto es:</p>

<p>\[<br>
y(n)=x(n)*\delta(n)=x(n)<br>
\]</p>

<p>Si desplazamos \(\delta(n)\) una cantidad \(k\) tenemos:</p>

<p>\[<br>
x(n)*\delta(n-k)=y(n-k)=x(n-k)<br>
\]</p>

<h4 id="toc_38">Ley conmutativa</h4>

<p>...Conmuta...</p>

<h4 id="toc_39">Ley asociativa</h4>

<p>...Es asociativa...</p>

<h4 id="toc_40">Interpretando...</h4>

<p>La interpretación de esto es que podemos componer sistemas concatenando respuestas al usar la operación de la convolución.</p>

<p><img src="./img/img7.png" alt=""><br>
<strong>Figura 7</strong></p>

<h4 id="toc_41">Ley distributiva...</h4>

<p>...Distribuye...<br>
pero lo choro es que podemos interpretar la distribución como enchufar dos sistemas en paralelo como muestra la fig 8</p>

<p><img src="./img/img8.png" alt=""><br>
<strong>Figura 8</strong></p>

<h3 id="toc_42">Estabilidad de los sistemas lineales invariantes en el tiempo</h3>

<p>Si \(x(n)\) es acotada, existe una constante tal que:</p>

<p>\[<br>
|x(n)|\leq M_x&lt;\infty<br>
\]<br>
De forma similar, si la salida está acotada, tenemos un \(M_y\) tal que:</p>

<p>\[<br>
|y(n)|\leq M_y&lt;\infty<br>
\]</p>

<p>Vamos a ver qué pasa con señales en un sistema, para esto vamos a usar la fórmula de convolución</p>

<p>\[<br>
y(n)=\sum_{k=-\infty}^\infty h(k)x(n-k)<br>
\]</p>

<p>si tomamos el valor absoluto, tenemos:</p>

<p>\[<br>
|y(n)|=\left|\sum_{k=-\infty}^\infty h(k)x(n-k)\right|<br>
\]</p>

<p>Así:</p>

<p>\[<br>
|y(n)|\leq \sum_{k=-\infty}^\infty |h(k)||x(n-k)|<br>
\]</p>

<p>Si la entrada está acotada de tal manera que \(|x(n)|\leq M_x\)</p>

<p>\[<br>
|y(n)|\leq M_x \sum_{k=-\infty}^\infty |h(k)|<br>
\]</p>

<p>Vemos así que la salida está acotada si la respuesta al impulso satisface:</p>

<p>\[<br>
S_h \equiv \sum_{k=-\infty}^\infty |h(k)|&lt;\infty<br>
\]</p>

<p>así: <em>un sistema lineal invariante en el tiempo es estable si su respuesta al impulso es absolutamente sumable.</em> Si \(S_h=\infty\) (me da cosa escribir eso pero no me quedó otra, el libro lo hace así y no supe hacerle el quite uwu), existe una entrada acotada para la cual la salida no es acotada.</p>

<h2 id="toc_43">Sistemas discretos en el tiempo descritos mediante ecuaciones en diferencias</h2>

<p>Hasta ahora todos los sistemas vistos están caracterizados por su respuesta al impulso \(h(n)\) de la siguiente manera:</p>

<p>\[<br>
y(n)=\sum_{k=-\infty}^\infty h(k)x(n-k)<br>
\]</p>

<p>En general si el sistema involucra un numero finito de datos (sistemas FIR <em>finite impulse response</em>) no hay rollo y la convolución se puede usar porque hay un número finito de operaciones involucradas para encontrar la respuesta de un sistema. En cambio, si el sistema es IIR (<em>infinite impulse response</em>) fuimos buenos. Entonces... ¿habrá otra manera de calcular sus respuestas? pos sí, se puede, con ecuaciones en diferencias. esto es muy útil para muchas cosas, como filtros digitales y modelamiento de sistemas físicos.</p>

<h3 id="toc_44">Sistemas discretos en el tiempo recursivos y no recursivos</h3>

<p>Embeces queremos modelar cosas no nos basta con los valores presentes de la señal, ni con las entradas pasadas, sino que también nos pueden importar señales pasadas, por ejemplo:</p>

<blockquote>
<p>Supongamos que queremos calcular la media acumulada de una señal \(x(n)\) en el intervalo \(0 \leq k \leq n\), definida como:<br>
\[<br>
y(n)=\frac{1}{n+1}\sum_{k=0}^n x(k), \quad n=0,1,...<br>
\]<br>
<em>Fuente: ejemplo sacado textual del libro</em></p>
</blockquote>

<p>Podemos ver que este problema nos pide ir guardando todas las entradas, gastando así mucha memoria al momento de implementar esto. Otra manera quizá más inteligente, es guardar solo el valor anterior, esto es \(y(n-1)\) y así nos ahorramos mucha memoria. Para esto hay que reordenar la expresión anterior:</p>

<p>\[<br>
\begin{aligned}<br>
  (n+1)y(n)&amp;=\sum_{k=0}^{n-1}x(k)+x(n)\\<br>
  &amp;=ny(n-1)+x(n)\\<br>
  &amp; \\<br>
  \implies y(n)&amp;=\frac{n}{n+1}y(n-1)+\frac{1}{n+1}x(n)<br>
\end{aligned}<br>
\]</p>

<p>Esto es, un sistema recursivo.</p>

<p>Ahora tenemos que un sistema causal se puede representar, como vimos en su momento, como:</p>

<p>\[<br>
y(n)=F[y(n),y(n-1),...,y(n-N),x(n),x(n-1),...,x(n-M)]<br>
\]</p>

<p>Donde \(F[\cdot]\) indica la función de sus argumentos.</p>

<h3 id="toc_45">Sistemas lineales invariantes en el tiempo caracterizados por ecuaciones en diferencias de coeficientes constantes</h3>

<p>Antes vimos la ecuación para calcular la media acumulada, esa ecuación era <em>variante en el tiempo</em> pq tenía coeficientes que variaban en el tiempo &rarr; no es una misma función de transferencia para todo \(n\).</p>

<p>Ahora, si tenemos constantes, entonces sí es invariante.</p>

<p>Ejemplo:</p>

<p>\[<br>
y(n)=ay(n-1)+x(n), \quad a=\text{constante}<br>
\]</p>

<p>Asumamos que hay una condición inicial \(y(-1)\), así nuestra pega es resolver un sistema con una señal de entrada \(x(n)\) dado por:</p>

<p><img src="./img/img9.png" alt=""><br>
<strong>Figura 9:</strong> varias iteraciones del sistema</p>

<p>De manera compacta tenemos:</p>

<p>\[<br>
y(n)=a{n+1}y(-1)+\sum_{k=0}^n a^k x(n-k), \quad n \geq 0<br>
\]</p>

<p>Tenemos que la respuesta del sistema, depende en primer lugar de una condición inicial y después de la señal que introducimos.</p>

<p>Se die que un sistema recursivo está en reposo si se inicia con condiciones iniciales nulas. A la &quot;memoria&quot; actual del sistema, le llamamos estado, y como es condiciones iniciales 0, le llamamos a la raspuesta con \(y(-1)=0\) <em>respuesta para al estado cero</em> y se designa \(y_{\text{zs}}(n)\)</p>

<p>Así la respuesta al estado cero del sistema anterior está dada por</p>

<p>\[<br>
y(n)=\sum_{k=0}^n a^k x(n-k), \quad n \geq 0<br>
\]</p>

<p>notemos que esto es una operación de convolución entre la señal de entrada y la respuesta al impulso:<br>
\[<br>
h(n)=a^nu(n)<br>
\]</p>

<p>Ahora supongamos el otro caso, donde la condicion inicial es \(y(-1)\neq0\) pero la señal de entrada es \(x(n)=0\), esta es la llamada <em>respuesta a entrada cero</em>, en este caso tenemos:</p>

<p>\[<br>
y_{\text{zi}}(n)=a^{n+1}y(-1), \quad n\geq0<br>
\]</p>

<p>vemos que este sistema no está en reposo en el sentido en que produce salida sin haber sido excitado por ninguna señal. La respuesta a la entrada cero se debe a la memoria del sistema.</p>

<p>Como vimos, la respuesta a entrada cero, no depende de la entrada, es por esto que es propia del sistema en el sentido que es la respuesta &quot;natural&quot; del sistema.</p>

<p>En general, la respuesta completa de un sistema se puede representar como:</p>

<p>\[<br>
y(n)=y_{\text{zi}}(n)+y_{\text{zs}}(n)<br>
\]</p>

<h4 id="toc_46">Revisemos la linealidad de un sistema</h4>

<p>Un sistema es lineal si cumple con:</p>

<ul>
<li>La respuesta total es igual a la suma de las respuestas a la entrada nula y en estado cero</li>
<li>El principio de superposición se aplica a la respuesta para el estado nulo (<em>lineal para el estado nulo</em>)</li>
<li>El principio de superposición se aplica a la respuesta a la entrada nula (<em>lineal para la entrada nula</em>)</li>
</ul>

<h3 id="toc_47">Solución de las ecuaciones en diferencias lineales de coeficientes constantes</h3>

<p>Acá vamos a mostrar el <em>método directo</em> para la resolución de estas ecuaciones.</p>

<p>El objetivo de estas cosas es siempre, ser capaces de determinar \(y(n),\quad n\geq0\) del sistema, dada una entrada \(x(n),\quad n\geq0\). Este método supone que la solución general es la suma de dos partes:</p>

<p>\[<br>
y(n)=y_h(n)+y_p(n)<br>
\]</p>

<p>Donde \(y_h(n)\) se conoce como la <em>solución homogénea</em> y \(y_p(n)\) como la <em>solución particular</em></p>

<h4 id="toc_48">TODO: lo que viene acá es cómo resolver esta custión pero me lo voy a saltar pq son edos y no tengo tiempo ahora, si alguien quiere terminarlo, es libre de hacerlo</h4>

<h1 id="toc_49">Análisis en frecuencia de las señales continuas en el tiempo</h1>

<p>Tenemos un montón de señales exponenciales complejas armónicamente relacionadas:</p>

<p>\[<br>
x(n)=\sum_{k=-\infty}^\infty c_k e^{j2\pi kF_0 t}<br>
\]</p>

<p>esto es una señal periódica con periodo fundamental \(T_p=1/F_0\)</p>

<p>Podemos ver que nuestras señales exponenciales con \(k \in \{0, \pm 1, \pm 2, ...\}\) las vamos sumando y ponderando con el \(c_k\) que corresponda, así &quot;armando&quot; nuestra señal \(x(n)\)</p>

<p>Para obtener los coeficientes \(c_k\) multiplicamos ambos lados por la exponencial compleja \(e^{-j2\pi F_0 lt}\) e  integramos ambos lados en un periodo:</p>

<p>\[<br>
\int_{t_0}^{t_0+T_p} x(t) e^{-j2\pi F_0 lt} dt = \int_{t_0}^{t_0+T_p} e^{-j2\pi F_0 lt}  \left(\sum_{k=-\infty}^\infty c_k e^{j2\pi kF_0 t}\right)dt<br>
\]</p>

<p>Cambiando el órden de la sumatoria con el de la integral en el lado derecho tenemos:</p>

<p>\[<br>
\sum_{k=-\infty}^\infty c_k \int_{t_0}^{t_0+T_p}  e^{j2\pi F_0 (k-l) t}dt<br>
=\sum_{k=-\infty}^\infty c_k<br>
\left. \left[\frac{e^{j2\pi F_0(k-l)t}}{j2\pi F_0(k-l)}\right]\right|_{t_0}^{t_o+T_p}<br>
\]</p>

<p>Cuando \(k\neq l\) tenemos que la expresión es 0, en cambio si \(k=l\) tenemos que la exponencial es 1, así:</p>

<p>\[<br>
\int_{t_0}^{t_0+T_p}dt=T_p<br>
\]<br>
Ahora retomando la integral original (porque solo llevamos calculado un lado de la igualdad) tenemos:</p>

<p>\[<br>
\int_{t_0}^{t_0+T_p} x(t) e^{-j2\pi F_0 lt} dt=c_l T_p<br>
\]<br>
Porque recordemos \(k=l\)</p>

<p>Así:</p>

<p>\[<br>
c_l=\frac{1}{T_p}\int_{t \in T_p}x(t)e^{-j2\pi lF_0t}dt<br>
\]</p>

<p>Como \(t_0\) era un valor arbitrario, pusimos solo que importa integrar en un periodo.</p>

<p>La idea es que esta cosa converja a la señal original \(x(t)\), para garantizar esto, es <strong>suficiente</strong> (no necesarias) que se cumplan las <em>condiciones de Dirichlet</em>:</p>

<p><strong>Condiciones de Dirichlet:</strong></p>

<ul>
<li>La señal \(x(t)\) tiene un número finito de discontinuidades en cualquier período.</li>
<li>La señal \(x(t)\) contiene un número finito de máximos y mínimos en cualquier período.</li>
<li>La señal \(x(t)\) es absolutamente integrable en cualquier período, esto es:
  \[
  \int_{t_p}|x(t)|dt&lt;\infty
  \]</li>
</ul>

<p>En resumen, tenemos que si \(x(t)\) es una señal periódica y satisface las condiciones de Dirichlet, se puede representar mediante una serie de Fourier. Esto está resumido en la siguiente tabla:</p>

<p><img src="img/img10.png" alt=""><br>
<strong>Figura 10:</strong> Tabla sacada del libro, cap 4</p>

<p>Cuando \(x(t)\) es <strong>real</strong>, los coeficientes \(c_k\) y \(c_{-k}\) son complejos conjugados, así</p>

<p>\[<br>
\begin{aligned}<br>
  c_k&amp;=|c_k| e^{j\theta_k} \\<br>
  c_{-k}&amp;=|c_k| e^{-j\theta_k}<br>
\end{aligned}<br>
\]</p>

<p>Así:</p>

<p>\[<br>
x(t)=c_0+2\sum_{k=1}^\infty |c_k|\cos(2\pi k F_0t+\theta_k)<br>
\]</p>

<p>donde \(c_0\) es real cuando \(x(t)\) es real</p>

<p>De manera equivalente:</p>

<p>\[<br>
x(t)=a_0 +\sum_{k=1}^\infty \left[a_k\cos(2\pi k F_0 t)-b_k\sin(2\pi k F_0 t)\right]<br>
\]</p>

<p>Donde:<br>
\[<br>
a_0=c_0, \qquad a_k=2|c_k|\cos\theta_k,\qquad b_k=2|c_k|\sin\theta_k<br>
\]</p>

<p>La serie de Fourier con todo es la de la ecuación de síntesis, estas últimas son para el caso en que la señal es real.</p>

<p>\[<br>
\text{¡¡¡Con esto termina la materia para el C1 del segundo semestre del 2019, mucho éxito a tods!!!}<br>
\]</p>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e={html:"HTML",xml:"XML",svg:"SVG",mathml:"MathML",css:"CSS",clike:"C-like",javascript:"JavaScript",abap:"ABAP",actionscript:"ActionScript",apacheconf:"Apache Configuration",apl:"APL",applescript:"AppleScript",asciidoc:"AsciiDoc",aspnet:"ASP.NET (C#)",autoit:"AutoIt",autohotkey:"AutoHotkey",basic:"BASIC",csharp:"C#",cpp:"C++",coffeescript:"CoffeeScript","css-extras":"CSS Extras",fsharp:"F#",glsl:"GLSL",http:"HTTP",inform7:"Inform 7",json:"JSON",latex:"LaTeX",lolcode:"LOLCODE",matlab:"MATLAB",mel:"MEL",nasm:"NASM",nginx:"nginx",nsis:"NSIS",objectivec:"Objective-C",ocaml:"OCaml",parigp:"PARI/GP",php:"PHP","php-extras":"PHP Extras",powershell:"PowerShell",jsx:"React JSX",rest:"reST (reStructuredText)",sas:"SAS",sass:"Sass (Sass)",scss:"Sass (Scss)",sql:"SQL",typescript:"TypeScript",vhdl:"VHDL",vim:"vim",wiki:"Wiki markup",yaml:"YAML"};Prism.hooks.add("before-highlight",function(s){var a=s.element.parentNode;if(a&&/pre/i.test(a.nodeName)){var t,i,r=a.getAttribute("data-language")||e[s.language]||s.language.substring(0,1).toUpperCase()+s.language.substring(1),l=a.previousSibling;l&&/\s*\bprism-show-language\b\s*/.test(l.className)&&l.firstChild&&/\s*\bprism-show-language-label\b\s*/.test(l.firstChild.className)?i=l.firstChild:(t=document.createElement("div"),i=document.createElement("div"),i.className="prism-show-language-label",t.className="prism-show-language",t.appendChild(i),a.parentNode.insertBefore(t,a)),i.innerHTML=r}})}}();
</script>

<script type="text/x-mathjax-config">
(function () {

MathJax.Hub.Config({
	'showProcessingMessages': false,
	'messageStyle': 'none'
});

if (typeof MathJaxListener !== 'undefined') {
	MathJax.Hub.Register.StartupHook('End', function () {
		MathJaxListener.invokeCallbackForKey_('End');
	});
}

})();
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


</body>

</html>
